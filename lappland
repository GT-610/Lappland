#! /usr/bin/env python3
# Copyright 2022-2023 GT610. Licensed under GNU GPLv3.
# Repo URL: https://codeberg.org/GT610/lappland

import argparse
import hashlib
import io
import json
import os
import requests
import sys
import tarfile
from prettytable import PrettyTable 
from tqdm import tqdm

# Necessary variables
home = os.getenv('HOME')
lappland_home = home + '/.lappland/'
lappland_tmp  = lappland_home + 'tmp/'
lappland_conf = lappland_home + 'local.json'
ver = '2.99.0'

# make config folder
def check_dir():
    if not os.path.isdir(lappland_home):
        os.mkdir(lappland_home)
    if not os.path.isdir(lappland_tmp):
        os.mkdir(lappland_tmp)

# Check system architecture
def check_arch():
    arch = os.uname().machine
    if arch == 'aarch64' or 'armv8' in arch:
        arch = 'aarch64'
    elif arch == 'x86_64':
        arch = 'amd64'
    elif '86' in arch:
        arch = 'i386'
    elif 'arm' in arch:
        arch = 'armhf'
    else:
        print('Your device''s CPU architecture is not in support currently. Want support? Leave your needs in https://codeberg.org/GT610/lappland/issues/1 .')
        exit(1)
    return arch

# Check if the package exists
def load_local():
    if not os.path.isfile(lappland_config):
        with open(lappland_config,'w') as f:
            arch = check_arch()
            data = {
                'config': {
                    'arch': arch,
                    'version': ver
                }
            }
            json.dump(data,indent=4,fp=f)
    with open(lappland_config,'r') as f:
        config = json.load(f)
    return config

# Get list
def get_list():
    try:
        r = requests.get('https://cdn.jsdelivr.net/gh/GT-610/lappland@latest/src/list.json')
    except requests.exceptions.ConnectionError as e:
        print('Connection error:', e)
        exit(1)
    if not r.status_code == 200:
        print('Failed to get image list.')
        exit(1)
    return r.json()

#Save to local data
def save_local(data):
    with open(lappland_conf, 'w') as file:
        json.dump(data, file)

#Define load local data
def load_local():
    with open(lappland_conf, 'r') as file:
        return json.load(file)

#Using hashes (MD5 and SHA256) to check its status
#Calculate SHA256
def calc_sha256(data):
    return hashlib.sha256(json.dumps(data).encode()).hexdigest()

#Calculate MD5SUMS
def calc_md5(data):
    return hashlib.md5(json.dumps(data).encode()).hexdigest()

#Define a bool to return if the list is up to date
def is_local_list_up_to_date(remote_md5,remote_sha256):
    if not os.path.isfile(lappland_conf):
        return False
    local_data = load_local()
    local_md5 = calc_md5(local_data)
    local_sha256 = calc_sha256(local_data)
    if local_md5 == remote_md5 and local_sha256 == remote_sha256:
        return True

def show_list():
    if os.path.isfile(lappland_conf):
        with open(lappland_conf, 'r') as file:
            local_data = json.load(file)
            remote_data = get_list()
            print('Checking remote list...')
            remote_sha256 = calc_sha256(remote_data)
            remote_md5 = calc_md5(remote_data)
            if is_local_list_up_to_date(remote_md5,remote_sha256):
                print("Local image list is up to date.")
                data = local_data
            else:
                print("Fetching remote image list.")
                data = remote_data
                save_local(data)
    else:
        print("Fetching remote image list.")
        data = get_list()
        save_local(data)

    config = load_local()
    table = PrettyTable()
    arch = check_arch()
    table.field_names = ["Name","Version","Installed","Installable"]
    for i in lists.get('linux'):
        name = i
        infos = lists.get(name)
        version = infos.get ('version')
        installed = name in config.keys()
        installable = arch in infos.keys()
        table.add_row([name,version,installed,installable])
    print(table.get_string())

#Pull image
def pull_image(distro):
    arch = check_arch()
    lists = get_list()
    config = load_local()
    distro_tmp = lappland_tmp + distro
    if distro in config.keys():
        print('You have installed ' + distro)
        exit(1)
    if distro not in lists.keys():
        print(distro + ' not found')
        exit(1)
    infos = lists.get(distro)
    if arch not in infos.keys():
        print(distro + ' not support your arch')
        exit(1)
    if os.path.isfile(distro_tmp):
        print(distro + ' already downloaded')
        print('Skipping download')
    else:
        url = infos.get(arch)
        print('Pulling rootfs')
        r = requests.get(url,stream=True)
        if not r.status_code == 200:
            print('Something is wrong. Try again.')
            print('Network Error')
            exit(1)
        total_size = int(r.headers.get('Content-Length'))
        block_size = io.DEFAULT_BUFFER_SIZE
        t = tqdm(total=total_size,unit='iB',unit_scale=True)
        with open(lappland_tmp + distro,'wb') as f:
            for chunk in r.iter_content(block_size):
                t.update(len(chunk))
                f.write(chunk)
        r.close()
        t.close()
    if infos.get('check') == 'ubuntu':
        check_url = 'https://partner-images.canonical.com/core/' + infos.get('version') + '/current/MD5SUMS'
        check_sum_ubuntu(distro,check_url)
    elif infos.get('check') == 'no':
        print(distro + ' has no check method')
        print('skiping')
    else:
        check_url = url + '.' + infos.get('check')
        check_sum(distro=distro,url=check_url,check=infos.get('check'))
    
    if not infos.get('zip') == 'fedora':
        extract_file(distro,infos.get('zip'))
    else:
        extract_fedora()
    config_image(distro,infos)

def remove_image(distro):
    distro_path = lappland_home + distro
    print('Removing image '+ distro)
    os.system('chmod -R 777 ' + distro_path)
    os.system('rm -rf ' + distro_path)
    config = load_local()
    del config[distro]
    with open(lappland_config,'w') as f:
        json.dump(config,indent=4,fp=f)


def config_image(distro,infos):
    print('Configuring image')
    distro_path = lappland_home + distro
    resolv_conf = distro_path + '/etc/resolv.conf'
    with open(resolv_conf,'w') as f:
        f.write('nameserver 1.1.1.1\n')
        f.write('nameserver 8.8.8.8\n')
    config = load_local()
    config.update({distro : infos})
    with open(lappland_config,'w') as f:
        json.dump(config,indent=4,fp=f)
    print('All done')
    print('Run it with lappland run ' + distro)
    
def extract_file(distro,zip_m):
    distro_path = lappland_home + distro
    file_path = lappland_tmp + distro
    if os.path.isdir(distro_path):
        os.system('chmod -R 777 ' + distro_path)
        os.system('rm -rf ' + distro_path)

    zip_f = tarfile.open(file_path,'r:'+zip_m)
    if not os.path.isdir(distro_path):
        os.mkdir(distro_path)
    print('Extracting image')
    zip_f.extractall(distro_path,numeric_owner=True)

def extract_fedora():
    file_path = lappland_tmp+ 'fedora'
    distro_path = lappland_home + 'fedora'
    print('Extracting image')
    zip_f = tarfile.open(file_path)
    for i in zip_f.getnames():
        if 'layer.tar' in i:
            zip_name = i
    zip_f.extract(zip_name,lappland_tmp)
    zip_f.close()
    zip_f = tarfile.open(lappland_tmp + zip_name,'r')
    if not os.path.isdir(distro_path):
        os.mkdir(distro_path)
    zip_f.extractall(distro_path,numeric_owner=True)
    

def check_sum(distro,url,check):
    print('Checking file integrity')
    r = requests.get(url)
    file_path = lappland_tmp + distro
    if not r.status_code == 200:
        print('Can''t get checksum file,are you sure to continue? [y/N]',end=' ')
        a = ''
        input(a)
        if not a == 'y':
            print('Exiting')
            os.remove(file_path)
            exit(1)
        else:
            return
    sum_calc = hashlib.md5() if check == 'md5' else  hashlib.sha256()
    total_size = os.path.getsize(file_path)
    block_size = io.DEFAULT_BUFFER_SIZE
    t = tqdm(total=total_size,unit='iB',unit_scale=True)
    with open(file_path,'rb') as f:
        for chunk in iter(lambda: f.read(block_size ), b''):
            t.update(len(chunk))
            sum_calc.update(chunk)
    t.close()
    f.close()

    if sum_calc.hexdigest() in r.text:
        print('Checksum successfully')
        return 0
    else:
        print('Checksum error')
        print('Removing file')
        print('Exiting')
        os.remove(file_path)
        exit(1)

def check_sum_ubuntu(distro,url):
    r = requests.get(url)
    file_path = lappland_tmp + distro
    if not r.status_code == 200:
        print('Can''t get checksum file,are you sure to continue? [y/n]',end=' ')
        a = ''
        input(a)
        if not a == 'y':
            print('Exiting')
            os.remove(file_path)
            exit(1)
    sum_calc = hashlib.md5()
    total_size = os.path.getsize(file_path)
    block_size = io.DEFAULT_BUFFER_SIZE
    t = tqdm(total=total_size,unit='iB',unit_scale=True)
    with open(file_path,'rb') as f:
        for chunk in iter(lambda: f.read(block_size),b''):
            t.update(len(chunk))
            sum_calc.update(chunk)
    t.close()
    f.close()

    if sum_calc.hexdigest() in r.text:
        return 0
    else:
        print('Checksum error')
        print('Exiting')
        os.remove(file_path)
        exit(1)

def clean_tmps():
    print('Cleaning temporary files')
    os.system('rm -rf ' + lappland_tmp + '*')

def run_image(arg):
    distro = arg[0]
    config = load_local()
    if not distro in config.keys():
        print('You don''t have ' + distro + 'image')
        print('Pull it before running it')
        exit(1)
    distro_path = lappland_home + distro
    infos = config.get(distro)
    command = ''
    command += 'proot'
    command += ' --link2symlink'
    command += ' -S '
    command += distro_path
#   command += ' -b /sdcard'
#   command += ' -b /system'
#   command += ' -b /data/data/com.termux/files/home'
    command += ' -w /root'
    command += ' /usr/bin/env -i'
    command += ' HOME=/root'
    command += ' LANG=C.UTF-8'
    command += ' PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin'
    command += ' TERM=xterm-256color'
    command += ' /bin/'
    os.unsetenv('LD_PRELOAD')
    if 'shell' in infos.keys():
        command += infos.get('shell')
    else:
        with open(distro_path+"/etc/passwd") as f:
            passwd_dict={}
            for line in f:
                args = line.split(":")
                passwd_dict[args[0]]=args[6]
            shell=passwd_dict['root'].strip().split('/')
            if (shell[-1] != '' and len(shell[-1]) != 0):
                command += shell[-1]
            else:
                command += 'bash'

    command += ' --login'
    if len(arg) > 1:
        ext_com = ' '.join(arg[1:])
        os.system(command + ' -c ' + ext_com)
    else:
        os.system(command)

# Define help message
helpmessage = 'Project Lappland ' + ver + '\n\n images\t\t list remote images\n remove\t\t remove a local image\n pull\t\t pull a remote image\n run\t\t start a local image\n clean\t\t clean temporary files\n help\t\t show this detailed help'

# Parse auguments:
def parse_args():
    parser = argparse.ArgumentParser(prog='Lappland',description=helpmessage)
    parser.add_argument('command', choices=['images', 'remove', 'pull', 'run', 'clean', 'help'], help='Run \'help\' for detailed usage.')
    return parser.parse_args()


    

# Main func
if __name__ == "__main__":
    check_dir()
    args = parse_args()
    if args.command == 'pull':
        pull_image()
    elif args.command == 'images':
        show_list()
    elif args.command == 'remove':
        remove_image(args.fsdir)
    elif args.command == 'run':
        run_image(args.fsdir, args.user)
    elif args.command == 'clean':
        clean_tmps()
    elif args.command == 'help':
        print(helpmessage)
    else:
        print(helpmessage)
        exit(1)
